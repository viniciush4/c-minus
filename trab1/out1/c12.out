5: int -> INT
5: factorial -> ID
5: ( -> LPAREN
5: int -> INT
5: n -> ID
5: ) -> RPAREN
5: { -> LBRACE
6: if -> IF
6: ( -> LPAREN
6: n -> ID
6: == -> EQ
6: 1 -> NUM
6: ) -> RPAREN
6: { -> LBRACE
7: return -> RETURN
7: 1 -> NUM
7: ; -> SEMI
8: } -> RBRACE
8: else -> ELSE
8: { -> LBRACE
9: return -> RETURN
9: n -> ID
9: * -> TIMES
9: factorial -> ID
9: ( -> LPAREN
9: n -> ID
9: - -> MINUS
9: 1 -> NUM
9: ) -> RPAREN
9: ; -> SEMI
10: } -> RBRACE
11: } -> RBRACE
13: void -> VOID
13: main -> ID
13: ( -> LPAREN
13: void -> VOID
13: ) -> RPAREN
13: { -> LBRACE
14: int -> INT
14: x -> ID
14: ; -> SEMI
15: int -> INT
15: f -> ID
15: ; -> SEMI
17: x -> ID
17: = -> ASSIGN
17: input -> INPUT
17: ( -> LPAREN
17: ) -> RPAREN
17: ; -> SEMI
18: output -> OUTPUT
18: ( -> LPAREN
18: factorial -> ID
18: ( -> LPAREN
18: x -> ID
18: ) -> RPAREN
18: ) -> RPAREN
18: ; -> SEMI
19: } -> RBRACE
